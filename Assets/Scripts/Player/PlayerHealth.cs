using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using UnityEngine.SceneManagement;
using Scripts.Wall;
using UnityStandardAssets.Characters.ThirdPerson;

namespace Scripts.Player
{
    public class PlayerHealth : MonoBehaviour
    {
        public float maxSpeed = 1.5f;                                   // Maximum speed for the player
        public float minSpeed = 0.4f;                                   // Minimum speed
        public float movementBonus = 1.15f;                             // Bonus percentaje to movement
        public float maxHealth = 100;                                   // Maximum health for the player.
        public float startingHealth = 100;                              // The amount of health the player starts the game with.
        public float healthRegeneration = 2;                            // Health regenerated by second when the player is not losing health.
        public float currentHealth;                                     // The current health the player has.
        public Slider healthSlider;                                     // Reference to the UI's health bar.                
               
        bool isDead;                                                    // Whether the player is dead.
        bool damaged;                                                   // True when the player gets damaged.
        bool possessing;                                                // True when the player posses another character.

        IEnumerator resistanceCoroutine = null;
        IEnumerator regenerateCoroutine = null;
        ThirdPersonCharacter movement;
        float movementMultiplicator;
        float currentSpeed;

        void Awake ()
        {

            movement = GetComponent<ThirdPersonCharacter>();

            // Set the initial health of the player.
            currentHealth = startingHealth;
            
            // Start coroutine to regenerate player's health
            regenerateCoroutine = RenerateHealth();
            StartCoroutine(regenerateCoroutine);
        }

        IEnumerator RenerateHealth() {
            while (true)
            {
                if (currentHealth < maxHealth)
                {
                    //Debug.Log("Healing. Previous health: " + currentHealth.ToString() + "; new health: " + (currentHealth + healthRegeneration).ToString());
                    // Regenerate health
                    currentHealth += healthRegeneration;

                    // Check to regenerate only to the maximum posible health
                    if (currentHealth > maxHealth)
                    {
                        currentHealth = maxHealth;
                    }

                    //Show new health value
                    UpdateHealth();

                    //Wait for more health
                    yield return new WaitForSeconds(1);
                }
                else {
                    // Maximum health, do nothing
                    yield return null;
                }
            }
        }

        IEnumerator TakeDamage(float damage, float time)
        {
            while (true)
            {
                Debug.Log("Taking damage. Previous health: " + currentHealth.ToString() + "; new health: " + (currentHealth - damage).ToString());
                damaged = true;
                currentHealth -= damage;
                if (currentHealth < 0)
                {
                    currentHealth = 0;
                }
                yield return new WaitForSeconds(time);
            }
        }

        void OnTriggerStay(Collider other)
        {
            if (!isDead && currentHealth > 0)
            {
                if (other.tag == "Wall")
                {
                    if (resistanceCoroutine == null)
                    {
                        Resistance resistance = other.GetComponent<Resistance>();
                        resistanceCoroutine = TakeDamage(resistance.Damage, resistance.TimeInterval);
                        StartCoroutine(resistanceCoroutine);
                    }                    
                }
                
            }

            //Show new health value
            UpdateHealth();
        }

        void OnTriggerExit(Collider other)
        {
            if (resistanceCoroutine != null)
            {
                StopCoroutine(resistanceCoroutine);
            }            
            resistanceCoroutine = null;
            damaged = false;
        }
        

        void UpdateHealth()
        {
            ChangeSpeed();

            // Set the health bar's value to the current health.
            healthSlider.value = currentHealth;
            
            // If the player has lost all it's health and the death flag hasn't been set yet...
            if (currentHealth <= 0 && !isDead)
            {
                // ... it should die.
                Death();
            }
        }

        void ChangeSpeed()
        {
            movementMultiplicator = ( (currentHealth*movementBonus)/ maxHealth);
            if (movementMultiplicator > 1)
            {
                movementMultiplicator = 1;
            }

            currentSpeed = maxSpeed * movementMultiplicator;
            if (currentSpeed < minSpeed)
            {
                currentSpeed = minSpeed;
            }

            // Change movement speed
            movement.m_MoveSpeedMultiplier = currentSpeed;
            // Change animation speed
            movement.m_AnimSpeedMultiplier = currentSpeed;

        }

        void Death ()
        {
            isDead = true;
            StopCoroutine(regenerateCoroutine);
            if (resistanceCoroutine != null)
            {
                StopCoroutine(resistanceCoroutine);
            }
#if UNITY_EDITOR
            UnityEditor.EditorApplication.isPlaying = false;
#elif UNITY_WEBPLAYER
         Application.OpenURL(webplayerQuitURL);
#else
         Application.Quit();
#endif
        }


        public void RestartLevel ()
        {
            // Reload the level that is currently loaded.
            SceneManager.LoadScene (0);
        }
    }
}